@page "/"
@using BlazorTemplater
@using QRCodeGenerator.Pages.Atoms
@using QRCoder
@using System.Text
@using System.ComponentModel.DataAnnotations
@inject NavigationManager Nav
@inject IJSRuntime JS

<PageTitle>QR Maker</PageTitle>

<h1>QR Maker</h1>

<div class="qr-container mt-3">
    <div class="qr-preview qr-preview-lg">
        <label class="form-label">プレビュー</label>
        <div class="qr-image border border-1 border-dark rounded rounded-2">
            <QRCodeSvg Level="@Level" Body="@Body" width="100%" height="100%" />
        </div>
    </div>

    <EditForm class="qr-form d-flex flex-column gap-3" EditContext="_editContext">
        <DataAnnotationsValidator />

        <div>
            <label class="form-label" for="ECCLevelBox">誤り訂正レベル</label>
            <InputSelect class="form-select" id="ECCLevelBox" TValue="QRCodeGenerator.ECCLevel" @bind-Value="Level">
                <option value="@QRCodeGenerator.ECCLevel.L">レベルL（7%）</option>
                <option value="@QRCodeGenerator.ECCLevel.M">レベルM（15%）</option>
                <option value="@QRCodeGenerator.ECCLevel.Q">レベルQ（25%）</option>
                <option value="@QRCodeGenerator.ECCLevel.H">レベルH（30%）</option>
            </InputSelect>
        </div>

        <div>
            <label class="form-label" for="BodyBox">内容</label>
            <textarea class="form-control" rows="3" id="BodyBox" @bind="Body" @bind:event="oninput"></textarea>
        </div>

        <div class="qr-preview qr-preview-sm">
            <label class="form-label">プレビュー</label>
            <div class="qr-image border border-1 border-dark rounded rounded-2">
                <QRCodeSvg Level="@Level" Body="@Body" width="100%" height="100%" />
            </div>
        </div>

        <div>
            <div class="d-flex gap-2">
                <button type="button" class="btn btn-success flex-fill" @onclick="async () => await OnDownloadAsync(ExportFormat.Svg)">
                    ⬇SVG
                </button>
                <button type="button" class="btn btn-success flex-fill" @onclick="async () => await OnDownloadAsync(ExportFormat.Png)">
                    ⬇PNG
                </button>
            </div>
        </div>
    </EditForm>
</div>

@code {
    private const int _nameLength = 30;
    private const int PngPixelsPerModule = 20;

    private EditContext _editContext = default!;

    [SupplyParameterFromQuery(Name = "url")]
    private string? Url { get; set; }

    [SupplyParameterFromQuery(Name = "body")]
    private string? BodyQuery { get; set; }

    public QRCodeGenerator.ECCLevel Level { get; set; }

    [Required]
    public string? Body { get; set; }

    protected override void OnInitialized()
    {
        if (Url is { })
        {
            if (string.IsNullOrEmpty(new Uri(Url).Host)) Nav.NavigateTo(Url, false, true);
            else Nav.NavigateTo(string.Empty, false, true);
            return;
        }

        Body = BodyQuery;
        _editContext = new EditContext(this);
        _editContext.OnFieldChanged += (_, e) =>
        {
            if (e.FieldIdentifier.FieldName == nameof(Body))
            {
                UpdateUri();
            }
        };
    }

    protected override void OnParametersSet()
    {
        if (Body != BodyQuery)
        {
            Body = BodyQuery;
        }
    }

    private async Task OnDownloadAsync(ExportFormat format)
    {
        if (!_editContext.Validate()) return;
        if (Body is null) return;

        using var stream = format switch
        {
            ExportFormat.Svg => CreateSvgStream(Body),
            ExportFormat.Png => CreatePngStream(Body),
            _ => throw new InvalidOperationException($"Unknown format: {format}")
        };

        stream.Position = 0;
        using var streamRef = new DotNetStreamReference(stream);

        var name = $"qrcode_{Level}_{Trim(Body)}.{GetExtension(format)}";
        await JS.InvokeVoidAsync("downloadFileFromStream", name, streamRef);
    }

    private MemoryStream CreateSvgStream(string body)
    {
        var svg = new ComponentRenderer<QRCodeSvg>().Set(t => t.Level, Level).Set(t => t.Body, body).Render();

        var stream = new MemoryStream();
        using var writer = new StreamWriter(stream, Encoding.UTF8, bufferSize: 1024, leaveOpen: true);

        writer.Write(@"<?xml version=""1.0"" encoding=""utf-8""?>");
        writer.Write(svg);
        writer.Flush();

        stream.Position = 0;
        return stream;
    }

    private MemoryStream CreatePngStream(string body)
    {
        using var generator = new QRCodeGenerator();
        using var data = generator.CreateQrCode(body, Level);

        var png = new PngByteQRCode(data);
        var bytes = png.GetGraphic(PngPixelsPerModule);

        return new MemoryStream(bytes);
    }

    private static string GetExtension(ExportFormat format) => format switch
    {
        ExportFormat.Svg => "svg",
        ExportFormat.Png => "png",
        _ => "txt"
    };

    private void UpdateUri()
    {
        var uri = string.IsNullOrEmpty(Body)
            ? string.Empty
            : $"?body={Uri.EscapeDataString(Body)}";

        Nav.NavigateTo(uri, false, true);
    }

    private string Trim(string src)
    {
        if (src.Length < _nameLength) return src;
        return src.Remove(_nameLength);
    }

    public enum ExportFormat
    {
        Svg,
        Png
    }

}
